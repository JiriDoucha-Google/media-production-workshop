WEBVTT

1
00:07.800 --> 00:09.920
大家好 我叫Sacha Guddoy

2
00:09.920 --> 00:12.730
我是来自Grabyo的首席前端工程师

3
00:12.730 --> 00:15.349
今天 我将谈一谈HTML媒体元素的准确性

4
00:15.349 --> 00:18.350
以及同步性 我们的实际用例

5
00:18.350 --> 00:21.320
以及我们所面临的一些挑战

slide-2
00:21.320 --> 00:23.910
首先 让我来介绍一下Grabyo

7-p
00:23.910 --> 00:26.200
Grabyo是一个

8
00:26.200 --> 00:28.230
用于广播媒体制作的SaaS平台

9
00:28.230 --> 00:30.680
它的用户群体是商业广播公司

10-p
00:30.680 --> 00:33.110
我们使用web和基于云的技术

11
00:33.110 --> 00:36.993
为广播工作流提供远程分发能力

12-p
00:38.600 --> 00:41.230
我们的一些服务包括直播视频制作

13
00:41.230 --> 00:42.653
从直播视频流中剪辑

14
00:43.840 --> 00:45.240
非线性编辑和将创意媒体

15
00:45.240 --> 00:47.300
发布到各种终端 例如

16
00:47.300 --> 00:49.980
社交媒体或直播流

slide-3
00:49.980 --> 00:51.760
首先 我要谈一下HTML媒体API的

18
00:51.760 --> 00:54.230
准确性

19-p
00:54.230 --> 00:57.430
在媒体制作工作流中的一种常见技术

20
00:57.430 --> 01:01.280
是为媒体创建一个低分辨率 低比特率的

21
01:01.280 --> 01:02.450
草稿版本

slide-4
01:02.450 --> 01:04.100
当你在处理该媒体时

23
01:04.100 --> 01:05.330
当你在进行编辑等工作时

24
01:05.330 --> 01:07.000
你看到的就是这个版本

25-p
01:07.000 --> 01:09.280
然后当你完成编辑后

26
01:09.280 --> 01:14.280
你会把它输出到性能更强的机器上

27
01:14.611 --> 01:16.850
可能是你自己的机器

28
01:16.850 --> 01:19.400
会使用大量的资源去渲染

29
01:19.400 --> 01:21.460
源素材的

30
01:21.460 --> 01:23.100
最终高质量版本

31-p
01:23.860 --> 01:27.610
我们的一种常见做法是

32
01:27.610 --> 01:29.910
用户在web浏览器中

33
01:29.910 --> 01:31.350
选择视频的入点和出点

34
01:31.350 --> 01:33.610
然后我们会将其发送到另一个服务

35
01:33.610 --> 01:34.540
可能是在云端

36
01:34.540 --> 01:37.530
然后我们会用它来处理

37
01:37.530 --> 01:40.150
来自高质量源素材的最终版本

slide-5
01:40.150 --> 01:43.600
在这种工作流中 我们面临的一个问题是

39
01:43.600 --> 01:46.860
你从web媒体元素中

40
01:46.860 --> 01:49.410
得到的时间戳不够准确

41
01:49.410 --> 01:53.120
当另一个应用加载相同的时间戳时

42
01:53.120 --> 01:57.630
它们不一定代表视频的同一帧

43-p
01:58.220 --> 02:02.680
那么这就意味着当你在导出视频时

44
02:02.680 --> 02:06.112
你在回放查看入点和出点时

45
02:06.112 --> 02:08.370
可能会存在一帧的偏差 这不是很好

46-p
02:08.370 --> 02:10.260
在专业的工作流中 帧的准确性

47
02:10.260 --> 02:11.630
真的很重要

48
02:11.630 --> 02:14.781
在很多情况下 这种偏差可能非常明显

49-p
02:14.781 --> 02:19.170
要获取用户使用视频的当前位置

50
02:19.170 --> 02:23.250
最常见的方法是使用HTMLVideoElement的

51
02:23.250 --> 02:25.423
currentTime属性

52-p
02:26.500 --> 02:29.620
这样做的问题是它并不是很精确

53
02:29.620 --> 02:30.720
它是以秒为单位的

54
02:30.720 --> 02:32.700
而且它只给到两位小数精度

55
02:32.700 --> 02:36.270
因此 你只能精确到百分之一秒

56-p
02:36.270 --> 02:37.800
在一个帧速率为60的视频中

57
02:37.800 --> 02:41.520
每帧只持续大约16毫秒

58
02:41.520 --> 02:43.610
而你的时间戳

59
02:43.610 --> 02:45.980
只能精确到百分之一秒

60
02:45.980 --> 02:48.330
因此无法严丝合缝地切到

61
02:48.330 --> 02:50.130
那一帧上去

62-p
02:50.130 --> 02:53.350
不同的视频渲染工具也可能

63
02:53.350 --> 02:57.320
对时间有不同的定义

slide-6
02:57.320 --> 02:59.970
下一点是关于与DOM的同步

65-p
03:00.970 --> 03:03.760
我们另一个常见的用例是使用DOM接口

66
03:03.760 --> 03:06.220
实时操作和监控媒体

67
03:06.220 --> 03:08.830
例如 控制播放状态

68
03:08.830 --> 03:11.350
控制播放位置

69
03:11.350 --> 03:14.160
监控音频水平

70
03:14.160 --> 03:18.963
分析或操作视频或音频

71
03:19.910 --> 03:21.610
显示覆盖元素

72
03:21.610 --> 03:24.260
以及将不同的媒体片段同步到一起

slide-7
03:25.800 --> 03:28.900
在这些情况下 要求DOM尽可能准确地

74
03:28.900 --> 03:29.940
反映媒体的当前状态

75
03:29.940 --> 03:31.320
真的很重要

76-p
03:31.320 --> 03:36.320
通常情况下 DOM中的这些元素

77
03:37.150 --> 03:38.800
会随着媒体进行更新

78-p
03:38.800 --> 03:39.917
有两种方法可以做到这一点

79
03:39.917 --> 03:41.570
你可以使用事件监听器

80
03:41.570 --> 03:43.793
或者你可以使用requestAnimationFrame

81
03:45.420 --> 03:48.170
因为DOM和媒体元素不在同一个线程中运行

82
03:48.170 --> 03:51.820
所以它们已经在一定程度上

83
03:51.820 --> 03:52.653
不同步了

84
03:52.653 --> 03:55.263
媒体元素在它自己的线程中播放

85
03:56.840 --> 04:00.143
但DOM的更新依赖于主UI线程

86
04:01.500 --> 04:02.670
这意味着任何用户交互

87
04:02.670 --> 04:05.540
或在DOM线程中运行的其他东西

88
04:05.540 --> 04:09.520
都可以很容易地阻塞你的更新

89
04:09.520 --> 04:11.340
这意味着你的DOM对媒体中的事件描述

90
04:11.340 --> 04:12.383
有可能会滞后

91-p
04:13.970 --> 04:16.320
此外 性能成本可能很高

92
04:16.320 --> 04:19.200
比如因为你的音频水平

93
04:19.200 --> 04:22.150
每秒要变化60次

94
04:22.150 --> 04:24.700
那么你就要每秒更新60次DOM

95
04:24.700 --> 04:26.360
那么这对UI线程来说是一种负担

96
04:26.360 --> 04:28.830
而且大大降低了用户体验

slide-8
04:28.830 --> 04:32.670
下一点是关于编解码器

98-p
04:32.670 --> 04:37.170
所有主流浏览器都自带一系列视频编解码器

99
04:37.170 --> 04:39.580
通过对编解码器支持的扩展

100
04:39.580 --> 04:43.210
和对解码流程的底层访问 可以实现新的功能

101-p
04:43.210 --> 04:45.700
例如 你可以使用帧内编码

102
04:45.700 --> 04:47.720
来提高搜索性能

103
04:47.720 --> 04:51.860
你可以比实时搜索更快地提取缩略图

104
04:51.860 --> 04:54.381
你可以解码并存储特定的时间范围

105
04:54.381 --> 04:57.610
以便在非线性编辑场景中

106
04:57.610 --> 04:59.313
提供快速参考

107-p
05:00.320 --> 05:03.160
很明显 WebCodecs可以帮助

108
05:03.160 --> 05:05.340
解决很多问题

109
05:05.340 --> 05:07.773
让我们在底层访问解码流程

110
05:08.642 --> 05:10.930
这是我非常期待的事情

111
05:10.930 --> 05:13.540
但显然 到现在2021年10月

112
05:13.540 --> 05:17.890
浏览器对此的支持并不怎么好

slide-9
05:17.890 --> 05:20.970
我想谈的下一个部分是多线程

114-p
05:20.970 --> 05:23.440
我们经常需要在处理UI的同一线程上

115
05:23.440 --> 05:25.823
执行媒体操作

116
05:27.191 --> 05:32.300
例如 将视频渲染到画布上

117
05:32.300 --> 05:33.720
这不是特别理想

118
05:33.720 --> 05:36.830
因为这些任务有时相当耗费资源

119
05:36.830 --> 05:39.430
而且运行非常频繁 阻塞了UI线程

120
05:39.430 --> 05:42.200
降低了性能和用户体验

121-p
05:42.200 --> 05:44.740
如果你要在画布上绘制视频

122
05:44.740 --> 05:46.450
这可能会在

123
05:46.450 --> 05:48.100
每个requestAnimationFrame中运行

124-p
05:48.955 --> 05:51.100
显然 解决这最后一个问题的传统方法

125
05:51.100 --> 05:54.300
是使用多线程

126
05:54.300 --> 05:55.220
即WebWorkers

127
05:55.220 --> 05:57.893
你可以在WebWorker中执行密集线程

128
05:59.900 --> 06:02.930
这就提供了一个后台画布接口

129
06:02.930 --> 06:06.530
允许WebGL在Worker边界内

130
06:06.530 --> 06:08.860
向画布渲染

131-p
06:08.860 --> 06:11.960
但视频元素没有一个对等的API

132
06:11.960 --> 06:13.750
视频元素不能在Worker中使用

133
06:13.750 --> 06:14.850
它不能被访问

134-p
06:15.750 --> 06:19.590
这就麻烦了 因为视频到画布的渲染流程

135
06:19.590 --> 06:21.830
就必须在DOM线程中执行

136
06:21.830 --> 06:25.600
它不能单独运行在Worker中

slide-10
06:25.600 --> 06:27.140
以上就是我在这方面想为各位介绍的所有内容

138
06:27.140 --> 06:30.800
我希望我们所面临的一些用例和问题

139
06:30.800 --> 06:33.300
对大家有所启发

140
06:33.300 --> 06:35.700
我很期待听到

141
06:35.700 --> 06:36.943
你们的问题和反馈

142
06:36.943 --> 06:39.280
非常感谢 再见
