WEBVTT

1
00:06.160 --> 00:11.113
<v James Pearce>这是我们的基于web的编辑器，</v>

2.
00:12.200 --> 00:15.930
对于那些不熟悉编辑工作的人来说，

3.
00:15.930 --> 00:19.300
这是非常标准的方法

4.
00:19.300 --> 00:22.685
编辑工作的应用程序具备的，就是，你知道的，

5.
00:22.685 --> 00:25.560
通常的三窗口布局。

6.
00:25.560 --> 00:27.590
在左上角，我们有一个源代码查看器，

7.
00:27.590 --> 00:31.350
用于加载源视频，并对其进行剪辑，

8.
00:31.350 --> 00:32.853
并将它们添加到时间轴上。

9
00:33.780 --> 00:35.880
在底部。我们有一个时间轴视图，

10
00:35.880 --> 00:38.530
向我们展示我们的很多的音轨，

11
00:38.530 --> 00:40.530
和片段，在这些音轨中，

12
00:40.530 --> 00:43.920
在右上角，我们有一个视频播放器，

13
00:43.920 --> 00:46.900
可以让我尝试播放，

14
00:46.900 --> 00:49.970
播放我正在制作剪辑的视频，

15
00:49.970 --> 00:53.750
我在下面的视图中构建的时间轴。

16
00:53.750 --> 00:55.350
在左边，最左边，

17
00:55.350 --> 00:59.160
我们只能在系统中看到所有我们自己的可用资源，

18
00:59.160 --> 01:01.480
这样，我们就能找到一个源代码，

19
01:01.480 --> 01:03.300
并将其加载到源代码查看器中，

20
01:03.300 --> 01:05.800
或者就把它拖到时间轴上。

21-p
01:05.800 --> 01:09.860
这个编辑器，功能相当齐全，

22
01:09.860 --> 01:12.370
也就是说，我们会有任意数量的

23
01:12.370 --> 01:15.490
音轨，任意数量的片段。

24
01:15.490 --> 01:18.990
我们可以添加各种效果在这些片段上。

25
01:18.990 --> 01:21.660
我们可以在这些片段之间进行过渡转换。

26
01:21.660 --> 01:26.660
当然，我可以给特定的片段添加模糊效果，

27
01:27.460 --> 01:30.670
这会让我看到一个模糊的画面，

28
01:30.670 --> 01:32.720
我有一些可以使用的控件

29
01:32.720 --> 01:34.763
来调整它的模糊程度。

30-p
01:35.950 --> 01:38.560
我们已经可以实现很多很多的效果，

31
01:38.560 --> 01:40.920
而且，很显然，这个列表还会增加

32
01:40.920 --> 01:44.890
因为我们建立在用户需求之上。

33-p
01:44.890 --> 01:46.600
比如，说到过渡转换，

34
01:46.600 --> 01:50.210
根据用户的反馈，我们有多种选择方法，

35
01:50.210 --> 01:54.610
因而，我可以添加一个简单的圆圈擦除

36
01:54.610 --> 01:55.773
当我进行播放时候。

37
01:57.500 --> 02:02.500
并且再就是，控件可以用来调整转换的功能。

38-p
02:02.130 --> 02:06.780
说到有一些

39
02:06.780 --> 02:08.880
更丰富的内容，我可以使用添加到时间轴上，

40
02:08.880 --> 02:10.453
这是一个简短的总结。

41-p
02:11.840 --> 02:13.260
同样，在播放方面，

42
02:13.260 --> 02:16.130
很明显，我们有高性能的的播放器，

43
02:16.130 --> 02:20.540
这样我就可以在时间轴上来回拖动进度条，比如

44
02:20.540 --> 02:23.430
进行剪切、过渡转换和实现所有效果

45
02:23.430 --> 02:26.260
被渲染到视频查看器中。

46
02:26.260 --> 02:29.300
我可以播放，可以以不同的速度进行播放，

47
02:29.300 --> 02:31.427
所以我可以。。。
（视频音频失真）

48
02:31.427 --> 02:33.204
这里是1.5倍的速度进行播放，

49
02:33.204 --> 02:34.369
我们可以听到声音。

50
02:34.369 --> 02:35.913
（视频音频加速）

51
02:35.913 --> 02:38.460
当我播放的越来越快，在一些节点上

52
02:38.460 --> 02:41.930
音频停止，因为它变得没有用。

53
02:42.200 --> 02:43.571
同样，相反的操作也会是这样。

54
02:43.571 --> 02:47.362
（视频音频反向播放）

55
02:47.362 --> 02:50.862
我可以查看一部分音视频信息，

56
02:52.370 --> 02:55.000
简单的通过前后移动。

57-p
02:55.000 --> 02:57.680
我也可以通过帧移动。

58
02:57.680 --> 03:02.147
如果你能听到，你会听到唧唧声，告诉我...

59
03:02.147 --> 03:03.840
（视频音频以唧唧声播放）

60
03:03.840 --> 03:05.900
当我在音频中。

61
03:05.900 --> 03:07.300
如果我想寻找特定的某一个点

62
03:07.300 --> 03:10.710
在讲者的演讲中，

63
03:10.710 --> 03:12.849
我在找最后的“p”或最后的“s”，

64
03:12.849 --> 03:17.900
我可以通过帧的进退听到。

65-p
03:17.900 --> 03:20.320
这只是一个演示

66
03:20.320 --> 03:22.540
我们看到这个测试性能非常好，

67
03:22.540 --> 03:27.163
从媒体播放，包括音频和视频。

68-p
03:28.270 --> 03:30.170
来谈论这些技术

69
03:30.170 --> 03:31.630
就是基础支撑，

70
03:31.630 --> 03:34.330
和我们使用的APIs，

71
03:35.530 --> 03:40.530
我想，主要的，也可能最感兴趣的

72
03:40.650 --> 03:45.310
对这次研讨会来说，就是WebCodecs，

73
03:45.310 --> 03:49.877
我们使用WebCodecs去解码H264和AAC。

74-p
03:50.940 --> 03:55.200
在WebCodecs之前，我们使用WebAssembly，

75
03:55.200 --> 03:58.170
所以我们构建了自己的解码器，

76
03:58.170 --> 03:59.880
我们用WebAssembly编译了这些，

77
03:59.880 --> 04:03.300
我们在一个Web Worker上使用了这些

78
04:03.300 --> 04:06.480
去解码音视频信息，缓冲，

79
04:06.480 --> 04:08.570
然后，可以用访问获取

80
04:08.570 --> 04:12.683
在播放器中，我们需要快速，随机获取它们。

81-p
04:14.120 --> 04:17.630
因为我们构建了播放引擎的方式，

82
04:17.630 --> 04:19.260
我们很快就能，

83
04:19.260 --> 04:24.260
将WebAssembly解码器与WebCodecs解码器互换。

84
04:24.410 --> 04:28.197
我们得到的差不多相同，大家知道，

85
04:28.197 --> 04:30.150
代码没有太大变化，

86
04:30.150 --> 04:32.980
但他们的性能表现有了显著的提高，

87
04:32.980 --> 04:37.980
还有，功耗，以及相关的

88
04:39.460 --> 04:42.500
性能要素

89
04:42.500 --> 04:43.930
我们看到这方面有所改善。

90-p
04:43.930 --> 04:45.330
这真是挺好的。

91
04:46.620 --> 04:49.350
我之前也有提到Web Workers。

92
04:49.350 --> 04:52.930
在大多数情况下，我们试图将

93
04:52.930 --> 04:57.930
我们的整个解码和渲染流程完成在一个Worker。

94-p
04:58.760 --> 05:00.610
在大多数情况下，我们可以做到，

95
05:00.610 --> 05:03.180
如果可以使用OffscreenCanvas，

96
05:03.180 --> 05:05.850
我们可以进行整个端到端的视频解码

97
05:05.850 --> 05:09.200
和视频渲染在一个Worker里。

98-p
05:09.200 --> 05:11.700
音频就会有点问题，

99
05:11.700 --> 05:14.220
因为Web Audio API，

100
05:14.220 --> 05:18.300
大部分API都绑定在主UI thread，

101
05:18.300 --> 05:20.600
在原来时候，给我们带来了一些问题。

102
05:20.600 --> 05:22.450
我们不得不跳过一些障碍

103
05:22.450 --> 05:24.820
尽可能多地尝试和缓存，

104
05:24.820 --> 05:27.810
这样播放就不会受影响，

105
05:27.810 --> 05:31.270
如果我开始滚动这里的列表，

106
05:31.270 --> 05:36.270
会在UI thread上造成明显的负载。

107
05:36.820 --> 05:40.200
我们希望避免发生类似的

108
05:40.200 --> 05:42.990
视频暂停或播放暂停，

109
05:42.990 --> 05:46.490
因为音频无法及时解码。

110-p
05:46.490 --> 05:51.300
Web Audio是其中一个方面

111
05:51.300 --> 05:53.820
给我们造成了麻烦。

112
05:53.820 --> 05:56.420
我们有了一个适合我们的解决方案，

113
05:56.420 --> 05:57.540
但我想，在将来，

114
05:57.540 --> 05:59.990
或许，我们想要一个解决方案，就是

115
05:59.990 --> 06:04.110
将Web Audio API推送到Worker后台程序，

116
06:04.110 --> 06:04.963
如果可能的话。

117-p
06:05.860 --> 06:10.970
我们也使用WebGL去

118
06:10.970 --> 06:14.670
合成，去过渡转换，去实现效果，

119
06:14.670 --> 06:17.790
还有，任何会涉及到

120
06:17.790 --> 06:20.277
将视频渲染到屏幕的时候。

121
06:20.277 --> 06:22.330
还有，关于WebGL的优点，

122
06:22.330 --> 06:24.454
因为这是一个标准，

123
06:24.454 --> 06:29.240
shader语言是标准的，我们可以共享

124
06:29.240 --> 06:32.333
我们的渲染引擎中的shader代码。

125-p
06:33.410 --> 06:36.680
这意味着

126
06:36.680 --> 06:41.330
当最终时间轴渲染到

127
06:41.330 --> 06:45.400
一个高分辨率的表单，渲染引擎能够使用

128
06:45.400 --> 06:47.870
这些相同的shaders去实现相同的结果

129
06:47.870 --> 06:50.560
我们在这里看到的，你知道，

130
06:50.560 --> 06:55.263
在这种低质量，代理的，browse-quality的视频，

131
06:56.550 --> 06:59.283
我们正在渲染到屏幕上，这里。

132-p
07:01.120 --> 07:04.203
我认为这涵盖了主要的

133
07:05.140 --> 07:07.490
我们正在使用的重要的API

134
07:07.490 --> 07:11.180
总而言之，我们使用的是WebCodecs，

135
07:11.180 --> 07:13.348
但我们还是回退了WebAssembly，

136
07:13.348 --> 07:15.450
如果WebCodecs不能用

137
07:15.450 --> 07:17.100
我们仍然在使用WebAssembly

138
07:17.100 --> 07:21.433
去对我们需要的MP4文件进行解析，

139
07:24.250 --> 07:27.750
去再解析

140
07:27.750 --> 07:29.764
基本的streams

141-p
07:29.764 --> 07:32.460
我们正在使用Web Audio API

142
07:32.460 --> 07:34.990
就是我们希望看到它转移到

143
07:34.990 --> 07:39.680
Web Workers，我们正在使用WebGL，

144
07:39.680 --> 07:43.870
然后是，各种其他老的API

145
07:43.870 --> 07:45.570
把整个都关联在一起。

146-p
07:46.580 --> 07:48.230
我想这差不多涵盖了

147
07:48.230 --> 07:49.670
我想说的。

148
07:49.670 --> 07:51.690
我不知道，James，是否有什么问题，

149
07:51.690 --> 07:55.900
或者你想让我往前，去说一些其他的问题

150
07:55.900 --> 07:56.580
讲得更详细些？

151-p
07:56.580 --> 07:57.413
<v James Cain>是, 谢谢, James.</v>

152
07:57.413 --> 07:59.300
有一件事，我很感兴趣，

153
07:59.300 --> 08:01.360
就是如何管理内存缓冲区的，

154
08:01.360 --> 08:03.874
管理他们一直存在的状态？

155
08:03.874 --> 08:06.610
你可以从codec中得到帧，

156
08:06.610 --> 08:08.349
如何去处理他们？

157-p
08:08.349 --> 08:09.930
<v James Pearce>我们保留的缓冲区</v>

158
08:09.930 --> 08:12.320
是倾向于以当前位置为中心，

159
08:12.320 --> 08:16.630
我们有一个光标，你可以看到，在屏幕上。

160
08:16.630 --> 08:22.650
我们想做的就是去预测，基于到用户正在做什么，

162
08:22.650 --> 08:25.360
我们想要缓冲什么，以及我们想要缓冲多长时间。

163
08:25.360 --> 08:28.100
如果用户以1x倍加速播放，

164
08:28.100 --> 08:32.743
那么，我们会对缓冲进行加强处理

165
08:33.960 --> 08:36.720
在加速的方向。

166
08:36.720 --> 08:38.500
我们主要是缓冲帧，

167
08:38.500 --> 08:41.200
在当前光标位置之前，

168
08:41.200 --> 08:44.400
我们更多会丢弃缓冲

169
08:44.400 --> 08:46.340
对已经播放过了

170
08:46.340 --> 08:48.870
和位于当前光标位置后面的。

171-p
08:48.870 --> 08:51.400
如果我们是倒着播放的话，我们就会反过来，

172
08:51.400 --> 08:52.780
所以我们会提前缓冲，

173
08:52.780 --> 08:55.610
但我们总是会缓冲一部分，

174
08:55.610 --> 08:57.960
光标两侧至少有一些帧，

175
08:57.960 --> 08:59.960
在某些情况下，一两秒钟

176
08:59.960 --> 09:02.180
光标附近，因为我们不知道，

177
09:02.180 --> 09:05.180
我们无法预测用户是否会停止播放

178
09:05.180 --> 09:09.410
然后突然反过来，所以我们需要能够

179
09:09.410 --> 09:13.220
很快改变方向。

180-p
09:13.220 --> 09:15.330
这让我们有能力做到这一点，

181
09:15.330 --> 09:17.640
我们就在那里来回缓冲，

182
09:17.640 --> 09:19.230
并且前后播放。

183
09:19.230 --> 09:20.176
（视频音频失真）

184
09:20.176 --> 09:21.880
你知道，如果我在要回顾一个帧，

185
09:21.880 --> 09:24.690
我可以前后点击。

186-p
09:24.690 --> 09:27.770
我们可以这样做，因为我们保存了一个缓冲区

187
09:27.770 --> 09:30.820
围绕当前光标位置。

188
09:30.820 --> 09:33.660
显然，我们不能缓冲大量的内容，

189
09:33.660 --> 09:37.280
我们仅限于双方都可以实现的

190
09:37.280 --> 09:39.850
在浏览器上，这是合理的。

191
09:39.850 --> 09:42.190
如果我只是想换个位置

192
09:42.190 --> 09:45.900
在时间轴上，那么我们已经缓冲的所有内容都没有用，

193
09:45.900 --> 09:48.190
我们必须再去获取一次，

194
09:48.190 --> 09:51.700
但我们将再次建立一组新的缓冲帧，

195
09:51.700 --> 09:54.230
基于该光标位置。

196-p
09:55.130 --> 09:57.800
这是否回答了那个问题？

197-p
09:57.800 --> 09:59.470
<v James Cain>是的，我想是的，</v>

198
09:59.470 --> 10:01.740
我想我们应该到此为止。

199-p
10:01.740 --> 10:02.633
<v James Pearce>好的。</v>