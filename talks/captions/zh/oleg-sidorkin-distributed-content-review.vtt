WEBVTT

1
00:06.300 --> 00:10.200
大家好！我是 Oleg Sidorkin

2
00:10.200 --> 00:13.540
是来自 Bluescape 的首席软件架构师。

4-p
00:13.540 --> 00:17.740
也是协同浏览器技术开发人员

5
00:17.740 --> 00:23.140
这也将是我今天演讲的主题。

6
00:23.140 --> 00:26.940
全球疫情以及当下的远程工作模式

7
00:26.940 --> 00:30.660
改变了大家的协同工作环境。

8
00:30.660 --> 00:34.600
之前人们汇集在同一个地方

9
00:34.600 --> 00:37.340
的高清屏幕下是轻而易举的，

10
00:37.340 --> 00:38.900
如今则变得不再容易

11
00:38.900 --> 00:42.420
而且短期内也不会再回到从前。

12
00:42.420 --> 00:46.380
传统的网络会议和资源共享工具

13
00:46.380 --> 00:49.100
不适合小组工作，当涉及

14
00:49.100 --> 00:54.900
高保真内容时，例如艺术、动画、视频等。

16-p
00:54.900 --> 00:58.660
我们在 Bluescape 找到了一种新方法

17
00:58.660 --> 01:01.540
任何网站或基于 web 的工具

18
01:01.540 --> 01:04.940
都可以获得额外的功能，提供实时协同体验

19
01:04.940 --> 01:08.740
来检查、评论、编辑创造性内容。

20
01:08.740 --> 01:12.540
当用户或团队开始一个共享会议时，

21
01:12.540 --> 01:16.580
所需的网页在云端加载

22
01:16.580 --> 01:20.200
而精准副本和所有增量的变化

23
01:20.200 --> 01:22.500
均传递给所有关联的客户端，

24
01:22.500 --> 01:26.620
给予它们相同的质量、延迟

25
01:26.620 --> 01:29.200
以及相同的体验，正如浏览

26
01:29.200 --> 01:30.540
本地设备上的内容

27
01:30.540 --> 01:33.980
或者同一屏幕后的内容。

29-p
01:33.980 --> 01:36.780
在服务器端，我们使用 Chromium 作为 headless

30
01:36.780 --> 01:40.340
网页浏览器，这得益于它的开源特性

31
01:40.340 --> 01:44.340
以及成熟的 Chrome 开发工具协议（CDP）。

32
01:44.340 --> 01:47.380
另一个需要考虑的是

33
01:47.380 --> 01:50.900
Chrome 占有全球 65% 的浏览器份额。

34
01:50.900 --> 01:54.580
我们选取老式的 WebSockets 作为一种低延迟的

35
01:54.580 --> 01:56.820
通信协议，确保

36
01:56.820 --> 01:59.100
消息的正确传递。

37
01:59.100 --> 02:02.420
当我们尝试捕捉

38
02:02.420 --> 02:06.260
并向远程客户端交付实时的精准复制的网页时

39
02:06.260 --> 02:06.940
就会产生问题。

41-p
02:08.820 --> 02:12.500
W3C DOM4 引入 MutationObserver

42
02:12.500 --> 02:15.940
弃用 Mutation Events。MutationObserver 是一种很好的方式

43
02:15.940 --> 02:18.460
来获取关于 DOM 中的变动通知。

44
02:18.460 --> 02:20.420
但它没有提供足够的信息

45
02:20.420 --> 02:22.540
来理解确切的变化是什么

46
02:22.540 --> 02:24.820
并形成一个增量的 DOM 更新

47
02:24.820 --> 02:27.620
并传递给连接的客户端。

48
02:27.620 --> 02:32.420
我们最终注入了一些 JavaScript 代码

49
02:32.420 --> 02:36.600
将浏览器 DOM 转换为虚拟 DOM

50
02:36.600 --> 02:38.500
并计算差异

51
02:38.500 --> 02:39.940
虚拟 DOM 的新旧版本之间的差异。

52
02:39.940 --> 02:45.980
为了保持计算成本

53
02:45.980 --> 02:49.860
我们使用了持久数据结构和 MutationObserver 提供的提示

54
02:49.860 --> 02:54.380 
针对每个受影响的区域。

55
02:54.380 --> 02:57.980
虚拟 DOM 的不变性让我们能够

56
02:57.980 --> 03:01.600
通过三重相等的 JavaScript 运算符，

57
03:01.600 --> 03:03.860
利用浅比较，这样我们可以跳过

58
03:03.860 --> 03:06.460
对整个子树的分析，

59
03:06.460 --> 03:09.780
在我们知道它们肯定不会受到影响的前提下。

61-p
03:09.780 --> 03:16.260
它几乎适用于所有 DOM 元素，

62
03:16.260 --> 03:19.900
但也有一些例外。

63
03:19.900 --> 03:21.820
MutationObserver 不会感知画布元素的变化

64
03:21.820 --> 03:24.740
从画布上下文中提取的信息

65
03:24.740 --> 03:27.900
也带来一些问题。

66
03:27.900 --> 03:31.980
我们使用混合方案。对于较少动态的画布，

67
03:31.980 --> 03:37.260
例如图表，我们提取内容作为数据 URL

68
03:37.260 --> 03:40.860
这成为虚拟 DOM 中的一个特殊属性

69
03:40.860 --> 03:43.140
因此，可以使用相同的同步逻辑

70
03:43.140 --> 03:46.200
就像常规元素一样。

71
03:46.200 --> 03:48.580
对于具有高动态内容的画布

72
03:48.580 --> 03:51.420
特别是 WebGL，

73
03:51.420 --> 03:53.140
我们找到了一种实验方法，是基于

74
03:53.140 --> 03:55.940
captureStream API 和 WebRTC 视频流的。

76-p
03:57.600 --> 04:01.200
附加 MutationObserver 的文档

77
04:01.200 --> 04:03.980
不会感知 Shadow DOM 中的变化

78
04:03.980 --> 04:06.540
所以应该单独观察每一个这样的 shadowRoot，

79
04:06.540 --> 04:08.420
这为监控子系统添加了额外工作，

80
04:08.420 --> 04:10.100
但它是可以解决的。

81
04:10.100 --> 04:16.100
然而，在封闭模式下创建的 Shadow DOM 树

82
04:16.100 --> 04:20.500
对 JavaScript 变得不可见。

83
04:20.500 --> 04:22.780
这种情况，我们要么应该放弃，

84
04:22.780 --> 04:26.780
要么解决它，而我们所做的就是，

85
04:26.780 --> 04:29.940
对元素的 attachShadow 方法采用猴子补丁，来保持它们的开放状态。

86
04:29.940 --> 04:36.220
它可能与某些网站逻辑相矛盾，但确实有效。

88-p
04:36.260 --> 04:39.700
当我们把网页内容提供给

89
04:39.700 --> 04:43.180
所有关联客户端时，

90
04:43.180 --> 04:45.500
我们必须对其进行某种修改。

91
04:45.500 --> 04:48.900
我们去除了所有的 JavaScript 代码，

92
04:48.900 --> 04:52.140
有效地让网页变得被动和可嵌入，

93
04:52.140 --> 04:57.500
因此它甚至可以绕过 iframe 嵌入实现。

94
04:57.500 --> 05:00.600
所有 JavaScript 逻辑

95
05:00.600 --> 05:01.620
都在 headless 浏览器的云端执行。

96
05:01.620 --> 05:05.660
我们修补外部资源链接，

97
05:05.660 --> 05:08.340
因此所有这些服务也都来自云端。

98
05:08.340 --> 05:10.700
无法直接访问。

99
05:10.700 --> 05:12.540
这些是目标网站。

100
05:12.540 --> 05:16.140
我们注入事件处理程序来截取

101
05:16.140 --> 05:17.740
页面中的客户端交互，

102
05:17.740 --> 05:20.780
并将它们重新连接到网站的云端事例。

103
这样的拦截允许我们引入真正的共同浏览体验

104
05:25.220 --> 05:28.540
当网站的单个事例

105
05:28.540 --> 05:32.180
可以被多个分散式客户端

106
05:32.180 --> 05:34.340
有效地控制和查看时。

108-p
05:34.340 --> 05:38.380
未来还有更多挑战。

110-p
05:38.380 --> 05:43.380
事件处理程序区分由用户操作生成的

111
05:43.380 --> 05:44.740
“可信”事件

112
05:44.740 --> 05:47.780
和由脚本生成或修改的

113
05:47.780 --> 05:53.140
或是通过 dispatchEvent API 发送的合成事件。

114
05:53.140 --> 05:56.860
某些网站有效地利用了这一功能

115
05:56.860 --> 05:58.860
来确保用户输入的真实性。

116
05:58.860 --> 06:02.140
到目前为止，我们找到的解决方案是

117
06:02.140 --> 06:05.620
通过 Chrome DevTools 协议来处理此类事件。

118
06:05.620 --> 06:11.500
在这种情况下，它们成为可信事件。

119-p
06:11.500 --> 06:16.100
当涉及异常内容时，

120
06:16.100 --> 06:19.220
修补外部资源变得棘手。

121
06:19.220 --> 06:22.540
例如，浏览器可能忽略

122
06:22.540 --> 06:26.220
CSS 文件中的一组错误，但仍然显示有效部分

123
06:26.220 --> 06:29.180
而 node.js 生态系统中的大多 CSS 解析库

124
06:29.180 --> 06:32.180
将无法处理它们。

125
06:32.180 --> 06:35.340
我们当下使用的解决方案是

126
06:35.340 --> 06:40.460
尽可能模仿浏览器的行为，

127
06:40.460 --> 06:44.540
有效地提取这种逻辑，

128
06:44.540 --> 06:48.100
从浏览器代码库中解析出这样的 CSS 代码，

129
06:48.100 --> 06:49.580
这得益于它的开源特性。

131-p
06:49.580 --> 06:55.420
我们还发现页面同步逻辑

132
06:55.420 --> 06:57.740
对那些可以在客户端启用的

133
06:57.740 --> 07:03.600
侵入式的浏览器扩展很敏感。

134
07:03.600 --> 07:05.540
一些 DOM 更改是位置上的

135
07:05.540 --> 07:08.500
而且如果一个扩展以意想不到的方式改变了浏览器 DOM，

136
07:08.500 --> 07:11.180
那么同步协议

137
07:11.180 --> 07:12.540
可能会混淆。

138
07:12.540 --> 07:17.300
为了一定程度上缓解这个问题，

139
07:17.300 --> 07:22.660
我们为关键 DOM 元素引入了唯一标识符。

140
07:22.660 --> 07:27.500
JavaScript 也不公开对象指针和

141
07:27.500 --> 07:31.380
任何类型的对象标识，因此我们使用了树结构，

142
07:31.380 --> 07:34.900
我们利用了 Map 容器的一个区别属性

143
07:34.900 --> 07:40.700
其中 key 可以是任意值，包括 DOM 元素。

144
07:40.700 --> 07:43.700
保留这样一个映射，可以让我们

145
07:43.700 --> 07:46.300
为 DOM 元素引入唯一的标识符和对象指针

146
07:46.300 --> 07:50.100
并保持原始 DOM 的完整性

147
07:50.100 --> 07:56.900
而不对网站逻辑产生干扰。

149-p
07:56.900 --> 08:02.740
实现协同浏览，我们面临着许多挑战，

150
08:02.740 --> 08:06.200
我可能只描述了其中的四分之一。

151
08:06.200 --> 08:11.100
一个非常重要的部分是与

152
08:11.100 --> 08:14.940
相关 Web 技术的限制或设计决策有关。

153
08:14.940 --> 08:17.780
这是可以理解的，因为我们做的并不是

154
08:17.780 --> 08:20.580
大家通常所做的。

155
08:20.580 --> 08:23.380
我们正尝试实现完全的

156
08:23.380 --> 08:24.420
远程浏览体验。

157
08:24.420 --> 08:28.700
对于大多问题，我们要么设法

158
08:28.700 --> 08:32.740
找到了解决办法，要么引入了一些

159
08:32.740 --> 08:35.940
利用 Web 堆栈动态特性的技巧。

160
08:35.940 --> 08:40.620
因此，当它行得通时，一切完美。

161
08:40.620 --> 08:45.500
行不通时，寻求解决方案就很棘手

162
08:45.500 --> 08:48.540
这感觉就像穿越雷区一样。

163
08:48.540 --> 08:51.860
但最终将是可行的。

165-p
08:51.860 --> 08:57.940
谢谢大家。
