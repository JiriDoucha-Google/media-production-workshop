WEBVTT FILE

1
00:08.118 --> 00:10.657
大家好 欢迎来到我的演讲

2
00:10.657 --> 00:13.130
在演讲中 我将为大家介绍

3
00:14.460 --> 00:18.200
Clipchamp在过去12个月中

4
00:18.200 --> 00:21.510
大体上是如何采用WebCodecs的

5
00:21.510 --> 00:24.940
Clipchamp是一个浏览器中的视频编辑器

slide-3
00:24.940 --> 00:26.860
我们的使命是让任何人都能够

7
00:26.860 --> 00:28.650
讲述值得分享的故事

slide-4
00:28.650 --> 00:33.390
因此 我们在浏览器中打造了

9
00:33.390 --> 00:35.263
一个完整的视频编辑器

slide-5
00:36.720 --> 00:41.420
我们从公司成立早期就坚信

11
00:41.420 --> 00:45.720
只有浏览器平台

12
00:45.720 --> 00:48.230
才能兼具云服务的便利性

13
00:48.230 --> 00:51.270
和桌面应用的处理速度

14
00:51.270 --> 00:54.190
我们也一直在使用这种浏览器模式

slide-6
00:54.190 --> 00:57.500
首先 可能最重要的原因是

16
00:57.500 --> 00:59.330
这提供了优秀的用户体验

17
00:59.330 --> 01:03.790
而其原因是视频编辑的素材文件很大

18-p
01:03.790 --> 01:06.350
从商业角度来看 它还有一项很棒的优势

19
01:06.350 --> 01:09.860
即它的运行成本几乎为零

20
01:09.860 --> 01:12.700
硬件成本已经支付过了

21-p
01:12.700 --> 01:16.640
最后 还有隐私方面的问题

22
01:16.640 --> 01:19.650
隐私在这个时代显然非常重要

23
01:19.650 --> 01:22.860
你并不会把所有信息上传到云服务中

24
01:22.860 --> 01:25.900
它们会只留在你的设备上

25
01:25.900 --> 01:28.530
这显然是很好的隐私处理方式

slide-7
01:28.530 --> 01:31.660
诚然 浏览器仍是一个具有挑战性的平台

27
01:31.660 --> 01:33.710
特别是当你在执行

28
01:33.710 --> 01:35.470
像视频编解码这样的大型任务时

29-p
01:35.470 --> 01:39.240
而首要的就是资源分配问题

30
01:39.240 --> 01:42.340
内存仍然稀缺 性能也同样重要

31
01:42.340 --> 01:45.590
如果你使用软件编码模式

32
01:45.590 --> 01:49.470
视频编码成本会很高

33
01:49.470 --> 01:53.310
就像我们在很长一段时间内所做的那样

34
01:53.310 --> 01:55.350
而且对底层硬件能力的访问也有限

35
01:55.350 --> 01:59.440
没错 现在的确有了WebAssembly SIMD

36
01:59.440 --> 02:01.170
我们也利用了它 WebGL也存在很长时间了

37
02:01.170 --> 02:05.140
WebGPU刚刚推出 值得庆幸的是

38
02:05.140 --> 02:07.820
这显然是最适合WebCodecs发挥的地方

39-p
02:07.820 --> 02:12.590
我们现在也可以使用专门用于硬件加速的

40
02:12.590 --> 02:16.180
音视频编解码的逻辑单元

41
02:16.180 --> 02:17.990
这对我们来说非常好

42-p
02:17.990 --> 02:19.660
我在这里用紫色圈出的

43
02:19.660 --> 02:22.700
两个方面 即性能和

44
02:22.700 --> 02:23.940
对底层硬件能力的访问

45
02:23.940 --> 02:28.940
显然是WebCodecs要解决的挑战

slide-8
02:29.558 --> 02:32.820
目前存在多种视频处理流程

47
02:32.820 --> 02:36.680
其中可能最具挑战性的部分

48
02:36.680 --> 02:40.800
就是当你导出你一直在编辑的视频项目时

49
02:41.864 --> 02:44.230
你会把各种视频片段放在一起

50
02:44.230 --> 02:46.810
因此 该项目将这些片段组合在一起

51
02:46.810 --> 02:49.710
或者说能够组合在一起 输出为MP4文件

52
02:49.710 --> 02:53.600
然后你就可以发布至网页

slide-8
02:53.600 --> 02:54.390
这是一个相当复杂的过程 同样

54
02:54.390 --> 02:56.140
我们仍然是在浏览器中运行这一切

55
02:56.140 --> 02:58.980
目前它被细分为三个阶段

56-p
02:58.980 --> 03:03.980
在这里 我们有一个解码器

57
03:04.300 --> 03:05.550
它负责从你的源素材中

58
03:05.550 --> 03:08.810
提取原始帧流

59
03:08.810 --> 03:11.330
然后传到中间阶段

60
03:11.330 --> 03:14.400
我们称之为合成器

61
03:14.400 --> 03:19.150
在这里 所有这些片段被组合起来

62
03:19.150 --> 03:22.600
效果会分层排在顶部 而这一阶段

63
03:22.600 --> 03:26.220
又会产生一个由原始帧组成的流

64
03:26.220 --> 03:28.613
然后传入编码器

65
03:29.547 --> 03:32.180
将其输出为一个MP4文件

66-p
03:32.180 --> 03:36.213
我们基本上把WebCodecs改造成这样的架构

slide-9
03:37.700 --> 03:40.540
它将我刚才展示的FFmpeg的

68
03:40.540 --> 03:42.590
WebAssembly构建

69
03:42.590 --> 03:46.248
与WebCodecs API结合起来

70
03:46.248 --> 03:51.248
原理是在FFmpeg内部创建了编解码器存根

71
03:51.418 --> 03:55.210
而这些编解码器存根的作用是

72
03:55.210 --> 03:59.270
将WebAssembly构建调用到JavaScript域

73-p
03:59.270 --> 04:01.970
这就是经历了WebCodecs API的整个生命周期

74
04:03.120 --> 04:05.870
或者说是WebCodecs规范中的

75
04:05.870 --> 04:08.150
VideoEncoder API更为准确

76
04:08.150 --> 04:11.300
首先 显然你需要初始化和配置你的

77
04:11.300 --> 04:12.133
VideoEncoder实例

78-p
04:12.133 --> 04:17.300
然后你要经历推入原始帧的过程

79
04:17.300 --> 04:20.746
然后取出编码块

80
04:20.746 --> 04:23.450
将其放回FFmpeg

81
04:23.450 --> 04:25.690
然后将其放入容器格式

82
04:25.690 --> 04:28.310
最后停用并反初始化

83
04:28.310 --> 04:29.843
VideoEncoder实例

slide-10
04:33.990 --> 04:36.630
这对我们来说是相当有效的做法

85
04:36.630 --> 04:38.330
但它也存在着一些问题

86
04:38.330 --> 04:41.300
这也许是本次演讲中最有趣的部分

87-p
04:41.300 --> 04:43.120
也许还能

88
04:43.120 --> 04:45.910
在面临同样挑战的人群中激起一些讨论

89
04:45.910 --> 04:49.160
看看能否得出一些好的对策

90-p
04:49.160 --> 04:51.910
我们必须要做的是人工创建一个

91
04:51.910 --> 04:55.940
视频编码器的预检模拟运行 使用相同的参数

92
04:55.940 --> 04:58.578
相同的分辨率 相同的一切

93
04:58.578 --> 05:01.183
只是为了生成那块额外的数据

94-p
05:02.700 --> 05:02.970
我记得在WebCodecs API术语中

95
05:02.970 --> 05:07.260
这块数据被称为“描述”

96
05:07.260 --> 05:09.850
如果你了解H.264编码的话

97
05:09.850 --> 05:14.343
其中有这些二进制单位

98
05:15.320 --> 05:18.280
基本上是储存SPS/PPS的元数据 它必须

99
05:18.280 --> 05:23.280
被放到或者说必须被放回FFmpeg

100
05:23.350 --> 05:25.650
这样它就可以被放在容器格式的正确位置

101
05:25.650 --> 05:27.860
关于这个问题我就暂时先说到这里

102
05:27.860 --> 05:30.600
但是为了解决这个问题

103
05:30.600 --> 05:32.169
我们绞尽了脑汁

104-p
05:32.169 --> 05:35.970
还有一个问题 与WebCodecs关系不大

105
05:35.970 --> 05:38.810
主要是与FFmpeg有关

106
05:38.810 --> 05:41.410
因为FFmpeg通常作为命令行工具来使用

107
05:41.410 --> 05:44.340
这意味着它是一个典型的同步调用栈

108
05:44.340 --> 05:47.540
从本质上来说它并不适合WebCodecs

109
05:47.540 --> 05:49.920
因为任何浏览器

110
05:49.920 --> 05:52.200
几乎任何浏览器的API都是异步的

111
05:52.200 --> 05:55.200
你必须把FFmpeg的同步调用栈

112
05:55.200 --> 05:58.110
分解成多个异步调用

slide-11
05:58.110 --> 06:00.725
最后 我们有一个小小的愿望清单

114
06:00.725 --> 06:05.725
当前版本的WebCodecs 1.0

115
06:05.910 --> 06:06.750
显然是十分值得称赞的

116
06:06.750 --> 06:10.480
非常感谢所有推动这一标准的人

117
06:10.480 --> 06:13.180
他们在浏览器中实施了这一标准

118-p
06:14.480 --> 06:17.448
我能想象到这可能有点过了

119
06:17.448 --> 06:20.703
因为它是一项非常专业的功能

120
06:20.703 --> 06:24.130
尽管如此 就现在而言

121
06:24.130 --> 06:26.543
它也是值得赞叹的

122-p
06:27.510 --> 06:29.290
话虽如此 但我们还是希望

123
06:29.290 --> 06:32.870
它不会固步自封 而是进一步

124
06:32.870 --> 06:34.660
对标准进行迭代更新

125
06:34.660 --> 06:37.690
同时我们也有几点需求

126
06:37.690 --> 06:40.160
能让我们的工作更轻松一些

127-p
06:40.160 --> 06:42.390
有一个问题一直在困扰着我们

128
06:42.390 --> 06:46.870
我们目前也只是勉强解决了它

129
06:46.870 --> 06:50.685
即在VideoEncoder对象上没有主动背压机制

130
06:50.685 --> 06:54.930
VideoEncoder对象应当能够主动提示你

131
06:54.930 --> 06:59.320
对你传递原始视频帧的方式进行限流

132
06:59.320 --> 07:02.860
提示你缓冲区基本已经满了

133
07:02.860 --> 07:05.380
因此 要是VideoEncoder对象能提供一个事件

134
07:05.380 --> 07:08.400
主动提醒我们 说“先停下 等我指令”

135
07:08.400 --> 07:09.973
那就更好了

136-p
07:12.430 --> 07:14.500
另一个问题是现在

137
07:14.500 --> 07:17.120
配置视频编码器的方式

139
07:17.120 --> 07:19.280
主要是通过比特率

140
07:19.280 --> 07:22.490
这对许多典型的工作负载来说可以接受的

141
07:22.490 --> 07:24.490
想想流媒体场景等等

142
07:24.490 --> 07:26.490
但在我们的用例中

143
07:26.490 --> 07:29.350
对于视频编辑来说

144
07:29.350 --> 07:32.320
可能会更关注质量

145
07:32.320 --> 07:34.100
这里说的的是图像质量

146
07:34.100 --> 07:38.120
如果有某种语义上的

147
07:38.120 --> 07:38.953
质量调整旋钮就好了

148
07:38.953 --> 07:43.500
这更像是一个抽象的参数 范围从0到1

149
07:43.500 --> 07:49.300
1代表最佳质量 0代表最低质量

151
07:49.300 --> 07:50.940
以及两者范围之内的数值

152
07:50.940 --> 07:54.350
但这更像是一种客观的手段

153
07:54.350 --> 07:56.723
来取代比特率对质量进行控制

154-p
07:59.523 --> 08:01.380
显然 HDR越来越重要

155
08:01.380 --> 08:04.477
越来越多的显示器和手机都在使用HDR

156
08:04.477 --> 08:09.477
电视也差不多

157
08:09.570 --> 08:11.980
桌面显示器也许还没有那么普遍

158
08:11.980 --> 08:14.000
但如果看到WebCodecs也能支持HDR

159
08:14.000 --> 08:16.440
那就更好了

160-p
08:16.440 --> 08:17.700
HEVC解码

161
08:17.700 --> 08:21.670
我知道存在知识产权和专利责任的问题

162
08:22.740 --> 08:25.880
但如果WebCodecs能够接入

163
08:25.880 --> 08:29.170
设备上安装的任何编解码器

164
08:29.170 --> 08:31.770
即使它是选择性的 比如某些设备

165
08:31.770 --> 08:34.280
不支持HEVC编码也没关系

166
08:34.280 --> 08:37.390
我们必须在某种软件服务编码中

167
08:37.390 --> 08:39.106
提供一个备选方案

168
08:39.106 --> 08:40.870
但如果安装的编解码器

169
08:40.870 --> 08:43.460
至少能够通过WebCodecs的接入实现支持

170
08:43.460 --> 08:44.813
那就更好了

171-p
08:45.717 --> 08:49.350
可惜的是 有一些知名的公司

172
08:49.350 --> 08:53.700
不顾知识产权的困阻 努力推动HEVC的发展

173
08:53.700 --> 08:55.700
这也是我们想要迎合用户的需求

175-p
08:57.400 --> 08:59.620
我也提了 WebWorker内部的

176
08:59.620 --> 09:03.640
WebCodecs API的同步调用风格也会很有用

177-p
09:03.640 --> 09:07.680
我没有把与复用/解复用相关的放进来

178
09:07.680 --> 09:10.720
是因为我们可以通过FFmpeg支持这些功能

179
09:10.720 --> 09:13.133
这对我们来并不是什么挑战 可能对于

180
09:13.133 --> 09:16.870
WebCodecs API的早期采用者 这是最大的问题之一

181-p
09:16.870 --> 09:21.550
一般来说 WebCodecs本身并不提供任何

182
09:21.550 --> 09:26.550
解析视频文件的方法

183
09:26.960 --> 09:31.843
以及解复用的部分 输出一个MP4文件

185-p
09:35.129 --> 09:37.623
我不确定这方面有什么可能的解决方案

186
09:37.623 --> 09:40.640
但显然这部分有很多复杂的问题

187
09:40.640 --> 09:43.841
而FFmpeg已经支持了所有这些

188
09:43.841 --> 09:45.540
所以我没有把它放进来

189
09:45.540 --> 09:48.390
我不确定将其纳入WebCodecs是否是好事

190
09:48.390 --> 09:51.796
因为这个问题有别于其他的问题

191
09:51.796 --> 09:54.753
即便几乎所有使用WebCodecs的人

192
09:54.753 --> 09:57.153
都可能不得不以某种方式解决它

slide-12
09:59.400 --> 10:01.800
我的演讲到此结束

194
10:01.800 --> 10:03.413
谢谢 欢迎提问
