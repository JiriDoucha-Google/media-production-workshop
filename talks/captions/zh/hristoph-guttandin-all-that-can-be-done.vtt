WEBVTT FILE

1
00:07.400 --> 00:08.840
大家好 感谢邀请

2
00:08.840 --> 00:11.680
能参加这次研讨会是我的荣幸

3
00:11.720 --> 00:14.480
我演讲的题目是“能做的都会做到”

4
00:14.480 --> 00:17.500
希望最后我的演讲能够体现这个内涵

5
00:19.240 --> 00:21.800
我叫 Christoph Guttandin 拥有一家公司

6
00:21.800 --> 00:23.600
名字叫 Media Codings，我也做自由职业

7
00:23.600 --> 00:25.000
从其他一些公司接工作

8
00:25.000 --> 00:27.400
我觉得对这次研讨会

9
00:27.400 --> 00:28.360
最相关的两个公司

10
00:28.360 --> 00:31.760
可能就是Source Elements和InVideo

11
00:31.760 --> 00:33.320
我通用的网名

12
00:33.320 --> 00:35.800
是chrisguttandin

13
00:35.800 --> 00:36.680
如果你想和我聊一聊

14
00:36.680 --> 00:38.600
请随时联系我

15
00:38.600 --> 00:41.120
只需要在任意平台上发送信息给我就够了

16
00:43.720 --> 00:46.100
我接到在这个研讨会中讲话的邀请时

17
00:46.100 --> 00:47.520
我就觉得这是一个向世界展示

18
00:47.520 --> 00:49.800
我们愿望的极好机会

19
00:49.800 --> 00:53.500
所以我请同事们帮我准备了一张列表

20
00:53.500 --> 00:55.120
上面是我们将来想要实现的东西

21
00:55.120 --> 00:57.840
或者是已经实现了的东西

22
00:57.840 --> 01:00.000
但我们想做得更好

23
01:00.000 --> 01:00.560
如果可能的话

24
01:03.100 --> 01:06.400
列表第一项就是在WebRTC中使用自制代码

25
01:08.720 --> 01:10.840
这在某种程度上

26
01:10.840 --> 01:13.840
已经实现了有一段时间了

27
01:13.840 --> 01:16.280
你可以通过给音频数据

28
01:16.280 --> 01:18.400
和视频数据编码来做到这点

29
01:18.400 --> 01:20.560
然后你就能忽略WebRTC的媒体功能

30
01:20.560 --> 01:24.320
通过DataChannel传输数据

31
01:24.320 --> 01:26.360
但是这个过程非常繁杂

32
01:26.360 --> 01:29.560
并且至少对视频数据是不太准确的

33
01:29.560 --> 01:32.120
视频的每一帧都需要渲染到画布上

34
01:32.120 --> 01:33.760
然后再从画布上取得

35
01:33.760 --> 01:36.800
再交给WebAssembly

36
01:36.800 --> 01:38.560
在处理实时视频流时

37
01:38.560 --> 01:39.840
丢失几帧是非常常见的

38
01:41.840 --> 01:44.400
好在现在这种做法不再必要

39
01:44.400 --> 01:46.560
因为现在可以用WebCodecs完成这个任务

40
01:46.560 --> 01:47.720
效率大大提高

41
01:47.720 --> 01:51.720
但是它目前只在Chromium内核浏览器上有

42
01:51.720 --> 01:55.100
火狐正在想办法 但是不幸的是

43
01:55.100 --> 01:57.280
我不太清楚苹果对此的想法

44
01:59.520 --> 02:02.320
我们列表的下一项是部分解码

45
02:02.320 --> 02:04.720
这里我们指的是

46
02:04.720 --> 02:06.800
只解码某个媒体源的

47
02:06.800 --> 02:08.320
一个部分 甚至是某一帧

48
02:09.800 --> 02:12.240
处理音频数据有一种非常不正式的方法

49
02:12.240 --> 02:16.500
就是使用decodeAudioData()这个函数

50
02:16.500 --> 02:18.840
这个函数在AudioContext接口下可用

51
02:18.840 --> 02:21.280
但是它会自动给音频数据重采样

52
02:21.280 --> 02:23.680
到AudioContext的采样率

53
02:23.680 --> 02:26.200
这就意味着必须手动分析文件

54
02:26.200 --> 02:27.720
得到正确的采样率后

55
02:27.720 --> 02:29.280
才能开始解码

56
02:29.280 --> 02:34.320
decodeAudioData()只接受完整的文件

57
02:34.320 --> 02:36.500
这又是文件必须

58
02:36.500 --> 02:38.680
事先分析的一个理由

59
02:38.680 --> 02:40.480
我们需要找到它在哪里能被切分

60
02:40.480 --> 02:43.840
这不是那么简单的

61
02:43.840 --> 02:46.160
但是对于大多数文件类型都能做到

62
02:46.160 --> 02:48.000
如果做法正确 你也走运

63
02:48.000 --> 02:51.840
decondeAudioData()就会解码文件的一部分

64
02:51.840 --> 02:54.640
因为它以为它解码的是一个完整的文件

65
02:56.800 --> 02:59.400
但是在Safari的最新版本里

66
02:59.400 --> 03:01.120
decodeAudioData()有很大的问题

67
03:01.120 --> 03:03.560
似乎这个bug在代码库里已经修好了

68
03:03.560 --> 03:06.400
但是没人知道这个修复什么时候

69
03:06.400 --> 03:07.560
能给Safari用户使用

70
03:07.560 --> 03:13.720
要解码一个单独的视频帧 可以用一个

71
03:13.720 --> 03:16.000
媒体元素加载一个视频 然后使用seekToNextFrame()

72
03:16.000 --> 03:17.320
一个一个地找到每一帧

73
03:19.100 --> 03:21.200
但是这只能在火狐上用

74
03:21.200 --> 03:25.120
但是这些现在也不是必要的了

75
03:25.120 --> 03:27.720
因为现在Chromium上有了WebCodecs

76
03:27.720 --> 03:29.400
很快还会上火狐

77
03:31.560 --> 03:33.240
对于我们另一件很重要的事情是

78
03:33.240 --> 03:36.120
把工作量尽可能转移到其他线程

79
03:36.120 --> 03:38.200
最终主线程要做的

80
03:38.200 --> 03:40.120
就只有触发工作 而不是参与工作

81
03:40.120 --> 03:43.640
已经有了一些API

82
03:43.640 --> 03:45.000
采用了这种模式

83
03:45.000 --> 03:47.100
其中一个就是AudioWorklet

84
03:47.100 --> 03:48.640
还有一般的Web Audio API

85
03:48.640 --> 03:52.120
对于视频内容则有OffscreenCanvas

86
03:52.120 --> 03:54.100
能从Web Worker内使用

87
03:54.100 --> 03:57.280
最后则是在MediaStream中

88
03:57.280 --> 03:59.160
插入一个TransformStream

89
03:59.160 --> 04:01.840
再把它转换到Web Worker里

90
04:01.840 --> 04:05.720
但是浏览器对Web Audio API

91
04:05.720 --> 04:07.680
之外的其他东西没有好的支持

92
04:07.680 --> 04:10.560
Chromium支持所有这些API

93
04:10.560 --> 04:13.680
火狐有OffscreenCanvas的实现

94
04:13.680 --> 04:16.280
有特征标记 但是对于可转移流

95
04:16.280 --> 04:17.680
还没有什么说法

96
04:17.680 --> 04:20.760
通常我都不敢猜这些东西

97
04:20.760 --> 04:23.500
什么时候才会在Webkit或者Safari中可用

98
04:23.500 --> 04:28.600
我们常觉得麻烦的另一件事

99
04:28.600 --> 04:29.840
就是维持媒体的同步

100
04:29.840 --> 04:32.480
尤其是涉及一些视频或者音频处理时

101
04:32.480 --> 04:35.400
会导致其中之一被延迟

102
04:35.400 --> 04:38.640
在播放的时候保证视频和音频同步

103
04:38.640 --> 04:40.440
是一件非常麻烦的事情

104
04:40.440 --> 04:45.120
一个AudioContext有两个属性

105
04:45.120 --> 04:47.440
能通知我们一个AudioContext的声音

106
04:47.440 --> 04:50.800
在何时计划被用户听见

107
04:50.800 --> 04:53.680
这就能让我们保证视频帧

108
04:53.680 --> 04:56.200
和音频能够对应

109
04:56.200 --> 04:59.360
但是这些属性目前只在火狐里

110
04:59.360 --> 05:02.200
才能完全工作 至于哪些浏览器

111
05:02.200 --> 05:04.160
什么时候会更新

112
05:04.160 --> 05:06.320
或者是否会更新

113
05:06.320 --> 05:07.600
我就不知道了

114
05:07.600 --> 05:13.500
我们另一个热门话题就是

115
05:13.500 --> 05:15.760
选择输出设备的可能性

116
05:15.760 --> 05:16.720
而不是使用默认设备

117
05:16.720 --> 05:20.480
有一个函数可以调用

118
05:20.480 --> 05:22.200
能够改变一个媒体元素的输出设备

119
05:22.200 --> 05:24.320
但是现在它只在Chromium里能用

120
05:24.320 --> 05:26.480
名字叫setSinkld()

121
05:26.480 --> 05:30.120
据我所知 火狐目前正在

122
05:30.120 --> 05:33.400
开发selectAudioOutput()这个函数 它是一个

123
05:33.400 --> 05:35.760
允许音频输出设备使用权的新方法

124
05:35.760 --> 05:38.480
这基本上就是阻止他们

125
05:38.480 --> 05:39.640
提供setSinkld()的障碍

126
05:39.640 --> 05:43.800
Chromium浏览器已经暴露出音频输出设备了

127
05:43.800 --> 05:46.000
这就意味着实现selectAudioOutput()

128
05:46.000 --> 05:48.440
对于setSinkld()不是必要的

129
05:48.440 --> 05:52.640
但是我还是不知道苹果在干什么

130
05:52.640 --> 05:57.640
所以回看愿望单的时候

131
05:57.640 --> 05:59.400
看起来就更像一个任务清单了

132
05:59.400 --> 06:03.500
所有这些目前都能实现 现存的非正式方法

133
06:03.500 --> 06:05.800
也可以在今天或者将来

134
06:05.800 --> 06:07.600
被正式的实现所取代

135
06:07.600 --> 06:10.680
至少我们暂时可以忽略Safari

136
06:10.680 --> 06:14.720
不论如何 我想出了其他一些愿望

137
06:14.720 --> 06:16.560
这些愿望和规格参数什么的没关系

138
06:16.560 --> 06:18.800
而是更倾向于实现器

139
06:18.800 --> 06:24.800
愿望单上第一件事就是

140
06:24.800 --> 06:25.760
版本发行越无聊越好

141
06:25.760 --> 06:29.100
我觉得Chromium和火狐

142
06:29.100 --> 06:30.800
有比较好的流程确保这一点

143
06:30.800 --> 06:36.280
两个浏览器都发布每日构建

144
06:36.280 --> 06:38.560
现在Chromium的版本号是97

145
06:38.560 --> 06:41.760
火狐是95 但是具体的数字

146
06:41.760 --> 06:43.880
在这里没什么意义

147
06:43.880 --> 06:46.360
每过四周 每日构建

148
06:46.360 --> 06:48.800
就被推进到下一个阶段

149
06:48.800 --> 06:50.760
那时的每日构建

150
06:50.760 --> 06:52.000
就会成为beta版

151
06:52.000 --> 06:55.240
同样的 每日构建也会增加

152
06:55.240 --> 06:58.880
所以这些浏览器的每日构建内容

153
06:58.880 --> 07:02.160
都会在至少四周内

154
07:02.160 --> 07:03.160
进入beta

155
07:03.160 --> 07:07.200
再过四周后 beta版

156
07:07.200 --> 07:09.600
就会成为正式版 而每日构建

157
07:09.600 --> 07:11.400
不论当时状态如何

158
07:11.400 --> 07:13.100
都会变成新的beta版

159
07:13.100 --> 07:16.400
就像是一个稳定的更新流

160
07:16.400 --> 07:19.400
当一个功能进入beta版之后

161
07:19.400 --> 07:22.320
你就能计算出它向所有用户

162
07:22.320 --> 07:23.600
开放的日期

163
07:23.600 --> 07:26.800
整个流程都是非常可预测的

164
07:26.800 --> 07:28.840
确实也非常无聊

165
07:28.840 --> 07:32.800
我一般都在每日构建上测试我的代码

166
07:32.800 --> 07:35.100
检查回归错误

167
07:35.100 --> 07:37.720
保证当Chromium或者火狐的新版本发布时

168
07:37.720 --> 07:41.280
至少不会给我什么“惊喜”

169
07:41.280 --> 07:46.160
但是Safari就不一样了

170
07:46.160 --> 07:48.840
Safari有一个技术前瞻版本

171
07:48.840 --> 07:52.280
现在的版本号是133

172
07:52.280 --> 07:55.720
包含了大量实验性的

173
07:55.720 --> 07:57.680
和未完成的新功能的实现

174
07:57.680 --> 08:01.640
但是不确定这些功能中有哪些

175
08:01.640 --> 08:03.280
会包含在下一个稳定版本里

176
08:03.280 --> 08:05.680
他们把这个当成一个秘密

177
08:05.680 --> 08:09.680
技术前瞻和正式的Safari

178
08:09.680 --> 08:11.520
有完全无关的版号

179
08:11.520 --> 08:14.160
我个人猜测稳定版是

180
08:14.160 --> 08:17.320
技术前瞻版的一个子集 但我不敢肯定

181
08:17.320 --> 08:21.100
开发者们没有任何方法

182
08:21.100 --> 08:23.720
在将要放出的稳定版中测试应用

183
08:23.720 --> 08:26.440
只有在正式对所有用户开放时

184
08:26.440 --> 08:27.520
才能开始测试

185
08:27.520 --> 08:30.680
这在你想要开发一个稳定的

186
08:30.680 --> 08:34.520
用户能够信任的应用时

187
08:34.520 --> 08:35.800
是非常具有挑战性的

188
08:35.800 --> 08:40.680
另一个问题就是Safari的稳定版本

189
08:40.680 --> 08:42.400
每6个月才更新一次

190
08:42.400 --> 08:45.240
这就意味着每次回归测试的最小生命周期

191
08:45.240 --> 08:46.520
通常是6个月

192
08:46.520 --> 08:49.400
因为回归错误在版本公布之前

193
08:49.400 --> 08:52.360
是没法发现的 所以回归错误在Safari里

194
08:52.360 --> 08:53.480
也不是没有听说过

195
08:53.480 --> 08:57.800
我刚才提过 现在就有一个错误

196
08:57.800 --> 08:59.800
导致decodeAudioData()不能用 还有一个

197
08:59.800 --> 09:01.280
会破坏WebRTC的音频流

198
09:01.280 --> 09:05.400
这就引向我的下一个愿望

199
09:05.400 --> 09:09.100
我真心希望回归错误修复能越快越好

200
09:09.100 --> 09:12.400
想象一下你做了一个网页应用

201
09:12.400 --> 09:15.480
媒体用户每天都依赖它

202
09:15.480 --> 09:19.680
然后一个浏览器更新导致它没法用了

203
09:19.680 --> 09:25.600
我知道哪怕是Safari也会及时地

204
09:25.600 --> 09:26.600
做出安全性更新

205
09:26.600 --> 09:29.200
我希望修复回归错误

206
09:29.200 --> 09:30.360
也能一样及时

207
09:30.360 --> 09:37.800
我知道一些强大的功能

208
09:37.800 --> 09:39.480
可能被恶意网页滥用

209
09:39.480 --> 09:43.100
我也完全同意一些功能

210
09:43.100 --> 09:45.400
不应该默认向所有网页都开放

211
09:45.400 --> 09:48.720
但是我认为浏览器的用户

212
09:48.720 --> 09:51.320
应该能够允许一些网站

213
09:51.320 --> 09:53.440
访问文件系统

214
09:53.440 --> 09:54.680
录屏

215
09:54.680 --> 09:56.680
录制系统音频

216
09:56.680 --> 09:57.880
收到MIDI信息

217
09:57.880 --> 10:00.500
执行高优先级的线程

218
10:00.500 --> 10:03.800
等等

219
10:03.800 --> 10:05.500
我认为不需要每次

220
10:05.500 --> 10:06.480
都弹一个允许弹窗

221
10:06.480 --> 10:09.800
而是可以做成一个消息提示框

222
10:09.800 --> 10:11.680
通知用户这些功能的使用

223
10:11.680 --> 10:14.400
不管是API的调用还是别的什么

224
10:14.400 --> 10:18.800
重点是 我认为权力应该属于用户

225
10:18.800 --> 10:21.880
让他们自己决定要不要打开某些功能

226
10:21.880 --> 10:24.500
或者某些功能他们目前不想用

227
10:24.500 --> 10:30.500
同样地 作为一个开发者 我也希望

228
10:30.500 --> 10:32.720
能有这种权力 我说过 我喜欢

229
10:32.720 --> 10:35.480
在现行的浏览器版本

230
10:35.480 --> 10:37.360
和将要更新的版本上运行自动测试

231
10:37.360 --> 10:41.500
我在云端和本地都是这样

232
10:41.500 --> 10:43.120
使用BrowserStack和Sauce Labs等服务

233
10:43.120 --> 10:46.280
测试媒体API是比较困难的

234
10:46.280 --> 10:49.100
因为它们一般都需要用户参与才能工作

235
10:49.100 --> 10:51.640
但是当运行自动测试时

236
10:51.640 --> 10:52.880
明显就没有用户了

237
10:52.880 --> 10:57.000
在Chromium和火狐上可以设置一些标记

238
10:57.000 --> 11:01.280
但是它们记录得不是很好

239
11:01.280 --> 11:04.640
它们的更新也赶不上浏览器的功能

240
11:04.640 --> 11:08.000
还时不时地

241
11:08.000 --> 11:08.760
会出问题

242
11:08.760 --> 11:14.440
至少对我来说 在Safari上

243
11:14.440 --> 11:17.520
以编程模式启动浏览器时

244
11:17.520 --> 11:20.500
甚至无法禁用自动播放策略

245
11:20.500 --> 11:24.000
这就意味着在Safari上做测试更加困难

246
11:24.000 --> 11:27.160
导致发现的错误更少

247
11:27.160 --> 11:29.360
这就很成问题 因为我提过了

248
11:29.360 --> 11:32.400
Safari里的一个错误

249
11:32.400 --> 11:33.280
至少会存在6个月

250
11:33.280 --> 11:36.400
而且还得在第一时间发现

251
11:36.400 --> 11:42.720
另一件不同的

252
11:42.720 --> 11:45.600
但是我认为也成问题的事就是

253
11:45.600 --> 11:48.400
做网页应用第一眼看上去似乎很轻松

254
11:48.400 --> 11:51.440
上周我看了一个完整的WebCodecs范例

255
11:51.440 --> 11:52.400
一张PPT就能放得下

256
11:52.400 --> 11:55.560
这令人赞叹 表明了

257
11:55.560 --> 11:57.800
只需要很短的时间就能开发出强大的功能

258
11:57.800 --> 12:00.720
这是完全正确的

259
12:00.720 --> 12:03.560
例如我就很快做出了一个应用

260
12:03.560 --> 12:05.240
能在浏览器内录制这次讲话

261
12:05.240 --> 12:08.320
我最终没用它 这里就不说了

262
12:08.320 --> 12:12.440
但是制作一个给专业人士

263
12:12.440 --> 12:15.640
日常使用的网页应用

264
12:15.640 --> 12:17.560
就完全不一样了

265
12:17.560 --> 12:21.680
需要付出很多努力

266
12:21.720 --> 12:25.320
很多人低估了在网页上

267
12:25.320 --> 12:27.600
制作完整产品需要的工作量

268
12:27.600 --> 12:30.760
在任何环境下

269
12:30.760 --> 12:32.560
开发专业应用都是很困难的

270
12:32.560 --> 12:35.880
更不用说在网页环境下了

271
12:35.880 --> 12:40.600
但是最后我认为这还是一个

272
12:40.600 --> 12:41.720
先有蛋还是先有鸡的问题

273
12:41.720 --> 12:45.120
一旦有几个知名度比较高的网页应用

274
12:45.120 --> 12:48.440
被专业媒体人广泛使用

275
12:48.440 --> 12:51.400
别人就会想把他们的应用

276
12:51.400 --> 12:52.240
搬到网页上

277
12:52.240 --> 12:56.200
例如Source Elements就有DAW的插件

278
12:56.200 --> 12:59.320
目前这是一个客户端应用程序

279
12:59.320 --> 13:00.600
因为真正要用的DAW

280
13:00.600 --> 13:02.360
都是客户端应用

281
13:02.360 --> 13:05.800
只有DAW变成了网页应用

282
13:05.800 --> 13:06.480
这点才可能改变

283
13:06.480 --> 13:10.400
肯定还有很长的路要走

284
13:10.400 --> 13:12.320
但是这个改变已经在发生了

285
13:12.320 --> 13:15.600
作为总结我想重申

286
13:15.600 --> 13:17.500
这次讲话的题目：

287
13:17.500 --> 13:20.400
“科技的一条基本原则就是

288
13:20.400 --> 13:21.600
能做到的都会做到”

289
13:21.600 --> 13:25.500
我认为 为网页环境开发

290
13:25.500 --> 13:27.500
专业的媒体应用现在是能被做到的

291
13:27.500 --> 13:29.600
我知道有很多人正在做这方面的工作

292
13:29.600 --> 13:34.240
我希望 也相信它会变成新常态

293
13:34.240 --> 13:35.760
只是时间问题

294
13:35.800 --> 13:40.480
再次感谢我的同事们

295
13:40.480 --> 13:42.160
帮我准备这次讲话

296
13:42.160 --> 13:44.840
感谢大家的观看

297
13:44.840 --> 13:47.900
研讨会见 再见
